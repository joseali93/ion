/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { InjectionToken, Injectable, Inject, Optional } from "@angular/core";
import { Validators, NG_VALIDATORS, NG_ASYNC_VALIDATORS } from "@angular/forms";
export const /** @type {?} */ DYNAMIC_VALIDATORS = new InjectionToken("DYNAMIC_VALIDATORS");
export class DynamicFormValidationService {
    /**
     * @param {?} NG_VALIDATORS
     * @param {?} NG_ASYNC_VALIDATORS
     * @param {?} DYNAMIC_VALIDATORS
     */
    constructor(NG_VALIDATORS, NG_ASYNC_VALIDATORS, DYNAMIC_VALIDATORS) {
        this.NG_VALIDATORS = NG_VALIDATORS;
        this.NG_ASYNC_VALIDATORS = NG_ASYNC_VALIDATORS;
        this.DYNAMIC_VALIDATORS = DYNAMIC_VALIDATORS;
    }
    /**
     * @param {?} validatorName
     * @param {?=} validatorArgs
     * @param {?=} validatorsToken
     * @return {?}
     */
    getValidatorFn(validatorName, validatorArgs = null, validatorsToken = this.NG_VALIDATORS) {
        let /** @type {?} */ validatorFn;
        if (Validators.hasOwnProperty(validatorName)) {
            // Built-in Angular Validators
            validatorFn = (/** @type {?} */ (Validators))[validatorName];
        }
        else {
            // Custom Validators
            if (this.DYNAMIC_VALIDATORS && this.DYNAMIC_VALIDATORS.has(validatorName)) {
                validatorFn = this.DYNAMIC_VALIDATORS.get(validatorName);
            }
            else if (validatorsToken) {
                validatorFn = validatorsToken.find(validatorFn => validatorFn.name === validatorName);
            }
        }
        if (validatorFn === undefined) {
            // throw when no validator could be resolved
            throw new Error(`validator "${validatorName}" is not provided via NG_VALIDATORS, NG_ASYNC_VALIDATORS or DYNAMIC_FORM_VALIDATORS`);
        }
        if (validatorArgs !== null) {
            return (/** @type {?} */ (validatorFn))(validatorArgs);
        }
        return /** @type {?} */ (validatorFn);
    }
    /**
     * @param {?} validatorsConfig
     * @param {?=} validatorsToken
     * @return {?}
     */
    getValidatorFns(validatorsConfig, validatorsToken = this.NG_VALIDATORS) {
        let /** @type {?} */ validatorFns = [];
        if (validatorsConfig && typeof validatorsConfig === "object") {
            validatorFns = Object.keys(validatorsConfig).map(validatorConfigKey => {
                let /** @type {?} */ validatorConfigValue = validatorsConfig[validatorConfigKey];
                if (this.isValidatorDescriptor(validatorConfigValue)) {
                    let /** @type {?} */ descriptor = /** @type {?} */ (validatorConfigValue);
                    return this.getValidatorFn(descriptor.name, descriptor.args, validatorsToken);
                }
                return this.getValidatorFn(validatorConfigKey, validatorConfigValue, validatorsToken);
            });
        }
        return validatorFns;
    }
    /**
     * @param {?} template
     * @param {?} model
     * @param {?=} error
     * @return {?}
     */
    parseErrorMessageConfig(template, model, error = null) {
        return template.replace(/{{\s*(.+?)\s*}}/mg, (_match, expression) => {
            let /** @type {?} */ propertySource = model, /** @type {?} */
            propertyName = expression;
            if (expression.indexOf("validator.") >= 0 && error) {
                propertySource = error;
                propertyName = expression.replace("validator.", "");
            }
            return propertySource[propertyName] ? propertySource[propertyName] : null;
        });
    }
    /**
     * @param {?} validatorName
     * @param {?=} validatorArgs
     * @return {?}
     */
    getValidator(validatorName, validatorArgs = null) {
        return /** @type {?} */ (this.getValidatorFn(validatorName, validatorArgs));
    }
    /**
     * @param {?} validatorName
     * @param {?=} validatorArgs
     * @return {?}
     */
    getAsyncValidator(validatorName, validatorArgs = null) {
        return /** @type {?} */ (this.getValidatorFn(validatorName, validatorArgs, this.NG_ASYNC_VALIDATORS));
    }
    /**
     * @param {?} validatorsConfig
     * @return {?}
     */
    getValidators(validatorsConfig) {
        return /** @type {?} */ (this.getValidatorFns(validatorsConfig));
    }
    /**
     * @param {?} asyncValidatorsConfig
     * @return {?}
     */
    getAsyncValidators(asyncValidatorsConfig) {
        return /** @type {?} */ (this.getValidatorFns(asyncValidatorsConfig, this.NG_ASYNC_VALIDATORS));
    }
    /**
     * @param {?} validatorsConfig
     * @param {?} control
     * @param {?} model
     * @return {?}
     */
    updateValidators(validatorsConfig, control, model) {
        model.validators = validatorsConfig;
        if (validatorsConfig === null) {
            control.clearValidators();
        }
        else {
            control.setValidators(this.getValidators(validatorsConfig));
        }
    }
    /**
     * @param {?} asyncValidatorsConfig
     * @param {?} control
     * @param {?} model
     * @return {?}
     */
    updateAsyncValidators(asyncValidatorsConfig, control, model) {
        model.asyncValidators = asyncValidatorsConfig;
        if (asyncValidatorsConfig === null) {
            control.clearAsyncValidators();
        }
        else {
            control.setAsyncValidators(this.getAsyncValidators(asyncValidatorsConfig));
        }
    }
    /**
     * @param {?} control
     * @param {?} model
     * @return {?}
     */
    createErrorMessages(control, model) {
        let /** @type {?} */ messages = [];
        if (typeof model.errorMessages === "object" && model.errorMessages !== null) {
            let /** @type {?} */ messagesConfig = /** @type {?} */ (model.errorMessages);
            Object.keys(control.errors || {}).forEach(validationErrorKey => {
                let /** @type {?} */ messageKey = validationErrorKey;
                if (validationErrorKey === "minlength" || validationErrorKey === "maxlength") {
                    messageKey = messageKey.replace("length", "Length");
                }
                if (messagesConfig.hasOwnProperty(messageKey)) {
                    let /** @type {?} */ validationError = control.getError(validationErrorKey), /** @type {?} */
                    messageTemplate = /** @type {?} */ (messagesConfig[messageKey]);
                    messages.push(this.parseErrorMessageConfig(messageTemplate, model, validationError));
                }
            });
        }
        return messages;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isFormHook(value) {
        return typeof value === "string" && ["blur", "change", "submit"].indexOf(value) !== -1;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isValidatorDescriptor(value) {
        if (value !== null && typeof value === "object") {
            return value.hasOwnProperty("name") && value.hasOwnProperty("args");
        }
        return false;
    }
}
DynamicFormValidationService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DynamicFormValidationService.ctorParameters = () => [
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [NG_VALIDATORS,] }] },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [NG_ASYNC_VALIDATORS,] }] },
    { type: Map, decorators: [{ type: Optional }, { type: Inject, args: [DYNAMIC_VALIDATORS,] }] }
];
function DynamicFormValidationService_tsickle_Closure_declarations() {
    /** @type {?} */
    DynamicFormValidationService.prototype.NG_VALIDATORS;
    /** @type {?} */
    DynamicFormValidationService.prototype.NG_ASYNC_VALIDATORS;
    /** @type {?} */
    DynamicFormValidationService.prototype.DYNAMIC_VALIDATORS;
}
//# sourceMappingURL=dynamic-form-validation.service.js.map